## 1. 引言
### 1.1  什么是设计模式
- 四个基本要素
	- 模式名称（pattern name）
	- 问题（problem）
	- 解决方案（solution）
	- 效果（consequences）
_设计模式是对被用来在特定场景下解决一般设计问题的类和相互通信的对象的描述_
### 1.2 Smalltalk MVC的设计模式
- 模型/视图/控制器（Model/View/Controller）三元组（MVC）
### 1.3 描述设计模式
- 模式名和分类
- 意图
- 别名
- 动机
- 适用性
- 结构
- 参与者
- 协作
- 效果
- 实现
- 代码示例
- 已知应用
- 相关模式
### 1.4 设计模式的编目
包含23个设计模式
- **Abstract Factory（3.1）**：提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们的具体的类。
- **Adapter（4.1）**：将一个类的接口转换成客户希望的另外一个接口。Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。
- **Bridge（4.2）**：将抽象部分与它的实现部分分离，使它们都可以独立的变化。
- **Builder（3.2）**：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。
- **Chain of Responsibility（5.1）**：为解除请求的发送者和接收者之间耦合，而使多个对象都有机会处理这个请求。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它。
- **Command（5.2）**：将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化：对请求排队或记录请求日志，以及支持可取消的操作。
- **Composite（4.3）**：将对象组合成树形结构以表示”部分-整体“的层次结构，Composite使得客户对单个对象和符合对象的使用具有一致性。
- **Decorator（4.4）**：动态地给一个对象添加一些额外的职责。就扩展功能而言，Decorator模式比生成子类方式更为灵活。
- **Facade（4.5）**: 为子系统中的一组接口提供一个一致的界面，Facade模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。
- **Factory Method（3.3）**：定义一个用于创建对象的接口，让子类决定将哪一个类实例化。Factory Method 使一个类的实例化延迟到子类。
- **Flyweight（4.6）**：运用共享技术有效地支持大量细粒度的对象。
- **Interpreter（5.3）**：给定一个语音，定义它的文法的一种表示，并定义一个解释器，该解释器使用该表示来解释语言中的句子。
- **Iterator（5.4）**：提供一种方法顺序访问一个聚合对象中各个元素，而又不需要暴露该对象内部表示。
- **Mediator（5.5）**:用一个中介对象来封装一系列的对象交互